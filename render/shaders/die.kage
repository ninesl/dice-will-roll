//go:build ignore

//kage:unit pixels

package main

var Time float
var DieScale float
var Direction vec2
var Velocity vec2
var DieColor vec3
var Height float
const pi float = 3.1415


// SDF functions
func sdSphere(pos vec3, size float) float {
    return length(pos) - size
}

func sdBox(p, b vec3) float {
    q := abs(p) - b
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0)
}

// Rodrigues' rotation formula
func rotate3D(p, axis vec3, angle float) vec3 {
    c := cos(angle)
    s := sin(angle)
    k := 1.0 - c
    return p*c + cross(axis, p)*s + axis*dot(axis, p)*k
}

func opSubtraction(d1, d2 float) float {
    return max(-d1, d2)
}

func opOnion(sdf, thickness float) float {
    return abs(sdf) - thickness
}

// FIX: Restore the onion effect for pips
func sdPip(p vec3, scale, d float) float {
    return opSubtraction(sdSphere(p, scale), d)
}

func calcDirection() vec3 {
    if length(Velocity) < 0.001 {
        return vec3(0.0, 0.0, 1.0) // Default axis when stopped
    }

    // Only rotate around axes where there's actual velocity
    rollAxis := vec3(0.0, 0.0, 0.0)
    
    // If moving in X direction, rotate around Y axis
    if abs(Velocity.x) > 0.001 {
        rollAxis.y = Direction.x
    }
    
    // If moving in Y direction, rotate around X axis  
    if abs(Velocity.y) > 0.001 {
        rollAxis.x = -Direction.y
    }

    if length(rollAxis) < 0.001 {
        return vec3(0.0, 0.0, 1.0) // Fallback
    }
    
    return normalize(rollAxis)
}

func calcRotation() float {
    velMag := length(Velocity)
    return -velMag * .01 * pi// Direct velocity-based rotation
}

func shape(p vec3) float {
    q := p
    
    // Simple rotation based ONLY on uniforms
    totalRotation := calcRotation()
    baseAngle := totalRotation * Time // No easing, no scaledTime bullshit
    
    throwDir := calcDirection()
    q = rotate3D(q, throwDir, baseAngle)
    
    // Die dimensions
    thirdScale := DieScale / 3.0
    third175 := thirdScale * 1.75
    third2 := thirdScale * 2.0
    quarterScale := DieScale / 4.5
    
    box := sdBox(q, vec3(DieScale))
    d := box
    
    // Add pips - NO ONION
    d = opSubtraction(sdSphere(vec3(q.x, q.y, q.z + DieScale), quarterScale), d)
    d = opSubtraction(sdSphere(vec3(q.x - DieScale, q.y - third175, q.z - third2), quarterScale), d)
    d = opSubtraction(sdSphere(vec3(q.x - DieScale, q.y + third175, q.z + third2), quarterScale), d)
    d = opSubtraction(sdSphere(vec3(q.x + third175, q.y + DieScale, q.z + third2), quarterScale), d)
    d = opSubtraction(sdSphere(vec3(q.x, q.y + DieScale, q.z), quarterScale), d)
    d = opSubtraction(sdSphere(vec3(q.x - third175, q.y + DieScale, q.z - third2), quarterScale), d)
    d = opSubtraction(sdSphere(vec3(q.x + third175, q.y - DieScale, q.z - third2), quarterScale), d)
    d = opSubtraction(sdSphere(vec3(q.x + third175, q.y - DieScale, q.z + third2), quarterScale), d)
    d = opSubtraction(sdSphere(vec3(q.x - third175, q.y - DieScale, q.z + third2), quarterScale), d)
    d = opSubtraction(sdSphere(vec3(q.x - third175, q.y - DieScale, q.z - third2), quarterScale), d)
    d = opSubtraction(sdSphere(vec3(q.x + DieScale, q.y - third175, q.z - third2), quarterScale), d)
    d = opSubtraction(sdSphere(vec3(q.x + DieScale, q.y + third175, q.z - third2), quarterScale), d)
    d = opSubtraction(sdSphere(vec3(q.x + DieScale, q.y, q.z), quarterScale), d)
    d = opSubtraction(sdSphere(vec3(q.x + DieScale, q.y - third175, q.z + third2), quarterScale), d)
    d = opSubtraction(sdSphere(vec3(q.x + DieScale, q.y + third175, q.z + third2), quarterScale), d)
    d = opSubtraction(sdSphere(vec3(q.x - third2, q.y - third175, q.z - DieScale), quarterScale), d)
    d = opSubtraction(sdSphere(vec3(q.x - third2, q.y, q.z - DieScale), quarterScale), d)
    d = opSubtraction(sdSphere(vec3(q.x - third2, q.y + third175, q.z - DieScale), quarterScale), d)
    d = opSubtraction(sdSphere(vec3(q.x + third2, q.y - third175, q.z - DieScale), quarterScale), d)
    d = opSubtraction(sdSphere(vec3(q.x + third2, q.y, q.z - DieScale), quarterScale), d)
    d = opSubtraction(sdSphere(vec3(q.x + third2, q.y + third175, q.z - DieScale), quarterScale), d)
    
    return d
}

//returns the color of pips if it hit one
func pips(col, finalPos vec3) vec3 {
    // Same rotation as shape()
    totalRotation := calcRotation()
    baseAngle := totalRotation * Time
    throwDir := calcDirection()
    q_hit := rotate3D(finalPos, throwDir, baseAngle)
    
    
    // Simple pip detection - NO ONION

    // Check ALL pip locations - NO ONION
    quarterScale := DieScale / 4.5
    thirdScale := DieScale / 3.0
    third175 := thirdScale * 1.75
    third2 := thirdScale * 2.0
    
    // Face 1 (Z+) - 1 pip
    if abs(sdSphere(q_hit - vec3(0.0, 0.0, -DieScale), quarterScale)) < 0.02 {
        col = vec3(0.1, 0.1, 0.1)
    }
    
    // Face 2 (X-) - 2 pips
    if abs(sdSphere(q_hit - vec3(DieScale, third175, third2), quarterScale)) < 0.02 {
        col = vec3(0.1, 0.1, 0.1)
    }
    if abs(sdSphere(q_hit - vec3(DieScale, -third175, -third2), quarterScale)) < 0.02 {
        col = vec3(0.1, 0.1, 0.1)
    }
    
    // Face 3 (Y+) - 3 pips
    if abs(sdSphere(q_hit - vec3(-third175, -DieScale, -third2), quarterScale)) < 0.02 {
        col = vec3(0.1, 0.1, 0.1)
    }
    if abs(sdSphere(q_hit - vec3(0.0, -DieScale, 0.0), quarterScale)) < 0.02 {
        col = vec3(0.1, 0.1, 0.1)
    }
    if abs(sdSphere(q_hit - vec3(third175, -DieScale, third2), quarterScale)) < 0.02 {
        col = vec3(0.1, 0.1, 0.1)
    }
    
    // Face 4 (Y-) - 4 pips
    if abs(sdSphere(q_hit - vec3(-third175, DieScale, third2), quarterScale)) < 0.02 {
        col = vec3(0.1, 0.1, 0.1)
    }
    if abs(sdSphere(q_hit - vec3(-third175, DieScale, -third2), quarterScale)) < 0.02 {
        col = vec3(0.1, 0.1, 0.1)
    }
    if abs(sdSphere(q_hit - vec3(third175, DieScale, -third2), quarterScale)) < 0.02 {
        col = vec3(0.1, 0.1, 0.1)
    }
    if abs(sdSphere(q_hit - vec3(third175, DieScale, third2), quarterScale)) < 0.02 {
        col = vec3(0.1, 0.1, 0.1)
    }
    
    // Face 5 (X+) - 5 pips
    if abs(sdSphere(q_hit - vec3(-DieScale, third175, third2), quarterScale)) < 0.02 {
        col = vec3(0.1, 0.1, 0.1)
    }
    if abs(sdSphere(q_hit - vec3(-DieScale, -third175, third2), quarterScale)) < 0.02 {
        col = vec3(0.1, 0.1, 0.1)
    }
    if abs(sdSphere(q_hit - vec3(-DieScale, 0.0, 0.0), quarterScale)) < 0.02 {
        col = vec3(0.1, 0.1, 0.1)
    }
    if abs(sdSphere(q_hit - vec3(-DieScale, third175, -third2), quarterScale)) < 0.02 {
        col = vec3(0.1, 0.1, 0.1)
    }
    if abs(sdSphere(q_hit - vec3(-DieScale, -third175, -third2), quarterScale)) < 0.02 {
        col = vec3(0.1, 0.1, 0.1)
    }
    
    // Face 6 (Z-) - 6 pips
    if abs(sdSphere(q_hit - vec3(third2, third175, DieScale), quarterScale)) < 0.02 {
        col = vec3(0.1, 0.1, 0.1)
    }
    if abs(sdSphere(q_hit - vec3(third2, 0.0, DieScale), quarterScale)) < 0.02 {
        col = vec3(0.1, 0.1, 0.1)
    }
    if abs(sdSphere(q_hit - vec3(third2, -third175, DieScale), quarterScale)) < 0.02 {
        col = vec3(0.1, 0.1, 0.1)
    }
    if abs(sdSphere(q_hit - vec3(-third2, third175, DieScale), quarterScale)) < 0.02 {
        col = vec3(0.1, 0.1, 0.1)
    }
    if abs(sdSphere(q_hit - vec3(-third2, 0.0, DieScale), quarterScale)) < 0.02 {
        col = vec3(0.1, 0.1, 0.1)
    }
    if abs(sdSphere(q_hit - vec3(-third2, -third175, DieScale), quarterScale)) < 0.02 {
        col = vec3(0.1, 0.1, 0.1)
    }
    
    return col
}

func Fragment(dstPos vec4, srcPos vec2, _ vec4) vec4 {
    uv := (srcPos * 2.0 - imageDstSize().xy) / imageDstSize().y
    
    ro := vec3(0.0, 0.0, Height)
    rd := normalize(vec3(uv * 0.5, 1.0))
    t := 0.0
    
    var hit bool
    var finalPos vec3
    
    for i := 0; i < 60; i++ {
        pos := ro + rd * t
        d := shape(pos)
        
        if d < 0.001 {
            hit = true
            finalPos = pos
            break
        }
        
        if t > 100.0 {
            break
        }
        
        t += d
    }
    
    if !hit {
        return vec4(0.0, 0.0, 0.0, 0.0)
    }


    //TODO: modify color based on t for shading
    col := DieColor
    col = pips(col, finalPos)
    return vec4(col, 1.0)
}