//go:build ignore

//kage:unit pixels

package main

var ZRandom float
var Time float
var DieScale float
var Direction vec2
var Velocity vec2
var DieColor vec3
var Height float
const pi = 3.141529

// SDF functions
func sdSphere(pos vec3, size float) float {
    return length(pos) - size
}

func sdBox(p, b vec3) float {
    q := abs(p) - b
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0)
}

func sdRoundBox(p, b vec3, r float) float {
    q := abs(p) - b + vec3(r)
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r
}

// Rodrigues' rotation formula
func rotate3D(p, axis vec3, angle float) vec3 {
    c := cos(angle)
    s := sin(angle)
    k := 1.0 - c
    return p*c + cross(axis, p)*s + axis*dot(axis, p)*k
}

func opSubtraction(d1, d2 float) float {
    return max(-d1, d2)
}

// sdPip subtracts a sphere (pip) from a distance field d.
func sdPip(p vec3, scale float, d float) float {
	return opSubtraction(sdSphere(p, scale), d)
}

func calcDirection() vec3 {
    // if length(Velocity) < 0.001 {
    //     return vec3(0.0, 0.0, 1.0) // Default axis when stopped
    // }

    // Only rotate around axes where there's actual velocity
    rollAxis := vec3(0.0, 0.0, 0.0)
    
    // If moving in X direction, rotate around Y axis
    if abs(Velocity.x) > 0.001 {
        rollAxis.y = Direction.x
    }
    
    // If moving in Y direction, rotate around X axis  
    if abs(Velocity.y) > 0.001 {
        rollAxis.x = -Direction.y
    }

    if length(rollAxis) < 0.001 {
        return vec3(0.0, 0.0, 1.0) // Fallback
    }
    
    rollAxis.z = normalize(rollAxis.x-rollAxis.y)

    return normalize(rollAxis)
}

func calcRotation() float {
    velMag := length(Velocity)
    return -velMag * .01 * pi// Direct velocity-based rotation
}

func pipPositions() [21]vec3 {
    thirdScale := DieScale  * .33
    third175 := thirdScale * 1.75
    third2 := thirdScale * 2.0


    return [21]vec3{
        // Face 1 (Z+)
        vec3(0.0, 0.0, DieScale),
        // Face 2 (X-)
        vec3(-DieScale, -third175, -third2),
        vec3(-DieScale, +third175, +third2),
        // Face 3 (Y+)
        vec3(+third175, +DieScale, +third2),
        vec3(0.0, +DieScale, 0.0),
        vec3(-third175, +DieScale, -third2),
        // Face 4 (Y-)
        vec3(+third175, -DieScale, -third2),
        vec3(+third175, -DieScale, +third2),
        vec3(-third175, -DieScale, +third2),
        vec3(-third175, -DieScale, -third2),
        // Face 5 (X+)
        vec3(+DieScale, -third175, -third2),
        vec3(+DieScale, +third175, -third2),
        vec3(+DieScale, 0.0, 0.0),
        vec3(+DieScale, -third175, +third2),
        vec3(+DieScale, +third175, +third2),
        // Face 6 (Z-)
        vec3(-third2, -third175, -DieScale),
        vec3(-third2, 0.0, -DieScale),
        vec3(-third2, +third175, -DieScale),
        vec3(+third2, -third175, -DieScale),
        vec3(+third2, 0.0, -DieScale),
        vec3(+third2, +third175, -DieScale),
    }
}

func shape(p vec3, pipPositions [21]vec3) float {
    q := p
    
    // Simple rotation based ONLY on uniforms
    totalRotation := calcRotation()
    baseAngle := totalRotation * Time // No easing, no scaledTime bullshit
    
    throwDir := calcDirection()
    q = rotate3D(q, throwDir, baseAngle)
        
    box := sdRoundBox(q, vec3(DieScale), .25)
    d := box
    
    quarterScale := DieScale * .2

    for i := 0; i < len(pipPositions); i++ {
        pip := pipPositions[i]
        d = sdPip(q-pip, quarterScale, d)
    }
    
    return d
}

//returns the color of pips if it hit one
func pipColors(originalDieSurfaceColor vec3, finalHitPos vec3, pipPositions [21]vec3) vec3 {
    // Same rotation as shape() to get q_hit in die's local space
    totalRotation := calcRotation()
    baseAngle := totalRotation * Time
    throwDir := calcDirection()
    q_hit := rotate3D(finalHitPos, throwDir, baseAngle)

    // Pip dimensions (must match shape function)
    quarterScale := DieScale * .2

    for i := 0; i < len(pipPositions); i++ {
        pipCenter := pipPositions[i]
        pipDist := sdSphere(q_hit - pipCenter, quarterScale)

        // If the hit point is inside this pip's carving sphere, we are on the pip's inner surface.
        if pipDist < 0.0 {
            // Calculate normalized depth: 0.0 at pip's rim, 1.0 at pip's center
            normalizedDepth := clamp(-pipDist/quarterScale, 0.0, 1.0)

            // Define how much to darken the pip from rim to center.
            // A higher power (e.g., 2.0) creates a more dramatic "scooped out" look.
            rimBrightness := 0.7   // Brightness at the very edge of the dip (70% of surface color)
            centerBrightness := 0.05 // Brightness at the deepest point (5% of surface color, almost black)
            
            // Calculate a darkening factor based on the depth.
            darkeningFactor := mix(rimBrightness, centerBrightness, pow(normalizedDepth, 2.0))

            // Apply the darkening factor to the original surface color.
            return originalDieSurfaceColor * darkeningFactor
        }
    }

    // If no pip was hit, return the original die surface color
    return originalDieSurfaceColor
}

func Fragment(dstPos vec4, srcPos vec2, _ vec4) vec4 {
    uv := (srcPos * 2.0 - imageDstSize().xy) / imageDstSize().y

    ro := vec3(0.0, 0.0, Height - 4.0)
    rd := normalize(vec3(uv * 0.5, 1.0))
    t := 0.0

    var hit bool
    var finalPos vec3

    pips := pipPositions()

    for i := 0; i < 55; i++ {
        pos := ro + rd * t
        d := shape(pos, pips)

        if d < 0.001 {
            hit = true
            finalPos = pos
            break
        }

        if t > 100.0 {
            break
        }

        t += d
    }

    if !hit {
        return vec4(0.0, 0.0, 0.0, 0.0)
    }

    col := DieColor

	// Apply simple fog/shading to darken distant objects
	// col *= (1.0 - clamp(t*0.05, 0.0, 0.8))
    col = 0.5*t * col //shading

    col = pipColors(col, finalPos, pips)

    return vec4(col, 1.0)
}