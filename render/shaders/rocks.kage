//go:build ignore

//kage:unit pixels

package shaders

var (
    // Rock generation parameters
    RockSeed float
    RockSize float
    Roughness float
    
    // Lighting parameters
    LightDirection vec3
    AmbientLight float
    DiffuseStrength float
    
    // Color parameters
    BaseColor vec3
    ColorVariation float
    
    // Animation parameters
    Time float
)

// Hash function for deterministic variation
func hash3D(p vec3) float {
    return fract(sin(dot(p, vec3(12.9898, 78.233, 45.164))) * 43758.5453)
}

// 3D rotation function
func rotate3D(p, axis vec3, angle float) vec3 {
    c := cos(angle)
    s := sin(angle)
    k := 1.0 - c
    return p*c + cross(axis, p)*s + axis*dot(axis, p)*k
}

// 3D SDF functions
func sdSphere(pos vec3, size float) float {
    return length(pos) - size
}

func sdBox(p, b vec3) float {
    q := abs(p) - b
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0)
}

func sdRoundBox(p, b vec3, r float) float {
    q := abs(p) - b + vec3(r)
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r
}

// Generate procedural rock shape using 3D SDFs
func generateRock(p vec3, seed float) float {
    // Use seed to create deterministic variation
    h1 := hash3D(vec3(seed, seed * 1.618, seed * 2.718))
    h2 := hash3D(vec3(seed * 3.141, seed * 1.414, seed * 0.577))
    h3 := hash3D(vec3(seed * 2.236, seed * 1.732, seed * 0.707))
    
    // Base rock shape - slightly irregular sphere
    baseShape := sdSphere(p, RockSize)
    
    // Add irregularity using multiple deformations
    deform1 := sin(p.x * 3.0 + seed * 10.0) * cos(p.y * 3.0 + seed * 15.0) * 0.2
    deform2 := sin(p.y * 5.0 + seed * 20.0) * cos(p.z * 5.0 + seed * 25.0) * 0.15
    deform3 := sin(p.z * 7.0 + seed * 30.0) * cos(p.x * 7.0 + seed * 35.0) * 0.1
    
    rock := baseShape + (deform1 + deform2 + deform3) * RockSize * Roughness
    
    // Add some smaller bumps
    bump1 := sdSphere(p + vec3(h1-0.5, h2-0.5, h3-0.5) * RockSize * 0.6, RockSize * 0.3)
    bump2 := sdSphere(p + vec3(h2-0.5, h3-0.5, h1-0.5) * RockSize * 0.4, RockSize * 0.25)
    
    // Smooth union for organic look
    k := 0.1
    h := clamp(0.5 + 0.5*(bump1-rock)/k, 0.0, 1.0)
    rock = mix(bump1, rock, h) - k*h*(1.0-h)
    
    h = clamp(0.5 + 0.5*(bump2-rock)/k, 0.0, 1.0)
    rock = mix(bump2, rock, h) - k*h*(1.0-h)
    
    return rock
}

func Fragment(dstPos vec4, srcPos vec2, _ vec4) vec4 {
    // Setup ray using die.kage approach
    uv := (srcPos*2.0 - imageDstSize().xy) / imageDstSize().y
    ro := vec3(0.0, 0.0, -3.0) // Camera position
    rd := normalize(vec3(uv*0.5, 1.0)) // Ray direction
    
    // Raymarch to find the surface
    t := 0.0
    var d float
    for i := 0; i < 60; i++ {
        pos := ro + rd*t
        d = generateRock(pos, RockSeed)
        if d < 0.001 {
            break
        }
        if t > 10.0 {
            t = 10.0
            break
        }
        t += d
    }
    
    // If we missed, return transparent
    if t >= 10.0 {
        return vec4(0.0, 0.0, 0.0, 0.0)
    }
    
    // Calculate final position and normal
    finalPos := ro + rd*t
    eps := vec2(0.001, 0)
    normal := normalize(vec3(
        generateRock(finalPos + eps.xyy, RockSeed) - generateRock(finalPos - eps.xyy, RockSeed),
        generateRock(finalPos + eps.yxy, RockSeed) - generateRock(finalPos - eps.yxy, RockSeed),
        generateRock(finalPos + eps.yyx, RockSeed) - generateRock(finalPos - eps.yyx, RockSeed),
    ))
    
    // Calculate lighting
    lightDir := normalize(LightDirection)
    diffuse := max(dot(normal, lightDir), 0.0)
    
    // Generate color variation based on position and seed
    colorVar := hash3D(finalPos * 2.0 + vec3(RockSeed))
    rockColor := BaseColor + vec3(colorVar - 0.5) * ColorVariation
    
    // Combine lighting
    lighting := AmbientLight + diffuse * DiffuseStrength
    finalColor := rockColor * lighting
    
    // Anti-aliasing using distance
    alpha := 1.0 - smoothstep(-0.01, 0.01, d)
    
    return vec4(finalColor, alpha)
}