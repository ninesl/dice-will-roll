//go:build ignore

//kage:unit pixels

package shaders            



var (
    Time float
    Resolution vec2
    Mouse vec2
    // NEW: Explicit rotation control for sprite sheet generation
    RotationX float
    RotationY float
    RotationZ float  // Z-axis rotation for spinning animation
    
    // Grayscale uniforms (0.0-1.0 range) for generating base white/gray sprites
    // These create depth/lighting variations that will be colored later via color_filter shader
    InnerColorDark vec3  // Dark gray for inner/crater areas
    InnerColorLight vec3 // Light gray/white for inner/crater areas
    OuterColorDark vec3  // Medium gray for outer surface
    OuterColorLight vec3 // Lighter gray for outer surface
)

const (

    pradius float = 1.3
    mradius float = 0.1
    iterations int = 20
    shadowit float = 10.0
    line float = 0.39

    // NCa vec4 = 
    // NCb vec4 = vec4(1.0, 158.0, 114.0, 271.0)
)

func hash4(n vec4) vec4 {
    return fract(sin(n)*753.5453123)
}

func noise3(x vec3) float {
    var p vec3 = floor(x)
    var f vec3 = fract(x)
    f = f*f*(3.0-2.0*f);
    var n float = p.x + dot(p.yz,vec2(157.0,113.0))
    var s1 vec4 = mix(hash4(vec4(n)+vec4(0.0, 157.0, 113.0, 270.0)),hash4(vec4(n)+vec4(1.0, 158.0, 114.0, 271.0)),vec4(f.x))
    return mix(mix(s1.x,s1.y,f.y),mix(s1.z,s1.w,f.y),f.z)
}

func heightMap(rad vec3, d float) float {
    var (
        iline float = 1.0 / (1.0 - line)
        a float = noise3(rad * 1.6) * 0.885
        na = a
    )

    if a > line {
        a = pow((a-line) * iline, 1.8) * (1.0 - line) + line
    }

    if abs(d-a) < 0.2 {
        na = na + noise3(rad * 8.0) * 0.1
        a = na
        if a > line {
            a = pow((a-line) * iline, 1.8) * (1.0 - line) + line
        }
    }
    if abs(d-a) < 0.02 {
        na = na + noise3(rad*32.0) * .01
        a = na
        if a > line {
            a = pow((a-line) * iline, 1.8) * (1.0 - line) + line
        }
    }
    if abs(d-a) < 0.01 {
        a = a + noise3(rad * 128.0) * 0.005
    }

    return a
}

func distObj(pos, ray vec3, radius, minr float) vec3 {
    var (
        b float = dot(ray, pos)
        c float = dot(pos, pos) - b*b

        sta float = radius - minr
        invm float = 1.0 / sta
        rq float = radius * radius
        dist vec3 = ray * 10000.0
    )
    if c < rq {
        r1 := (ray * (abs(b) - sqrt(rq-c)) - pos)
        var maxs float = abs(dot(r1, ray)) // * 0.5
        if c < minr * minr {
            var r2 vec3 = (ray * (abs(b) - sqrt(minr * minr) - c) - pos)
            maxs = maxs - abs(dot(r2, ray))
        }
        maxs = maxs * 0.5

        var len, h float
        for m := 0; m < iterations ; m++ {
            len = length(r1)
            var d vec3 = r1/len
            h = sta * heightMap(d, (len - minr) * invm) + minr
            if abs(h - len) < 0.0001 {
                break
            }
            maxs = abs(maxs)
            if len < h {
                maxs = -1.0 * maxs
            }
            r1 = r1 + (ray * maxs * abs(len - h))
            maxs *= 0.99
        }
        if (len < h +0.1) {
            dist = r1 + pos
        }
    }
    return dist
}

func noiseSpace(ray, pos vec3, r float, mr mat3, zoom float, subnoise vec3) float {
    var (
        b float = dot(ray, pos)
        c float = dot(pos, pos) - b*b
        // r1 vec3 = vec3(0.0)

        s float = 0.0
        d float = 0.0625 * 1.5
        d2 float = zoom / d
        // rq float = r * r
        l1 float = sqrt(abs(r - c))
        
        r1 vec3 = (ray * (b - l1) - pos) * mr
    )
    r1 = r1 * d2

    s = s + abs(noise3(vec3(r1 + subnoise)) * d)
    s = s + abs(noise3(vec3(r1*0.5 + subnoise)) * d * 2.0) 
    s = s + abs(noise3(vec3(r1*0.25 + subnoise)) * d * 4.0) 
    return s
}

func Fragment(dstPos vec4, srcPos vec2, _ vec4) vec4 {
    var p vec2 = (srcPos*2.0 - imageDstSize().xy) / imageDstSize().y
    
    // OLD: Mouse-based + time-based auto-rotation (commented out)
    // var mouseActive float = step(0.0, Mouse.x) * step(0.0, Mouse.y)
    // var rotate vec2 = vec2(
    //     mix(0.5, Mouse.x / Resolution.x * 10.0, mouseActive) + Time * 0.02,
    //     mix(0.0, Mouse.y / Resolution.y * 4.0 - 2.0, mouseActive),
    // )
    
    //. eyeball pos
    var pos vec3 = vec3(0.0,0.0,2.25)
    
    // NEW: Use explicit rotation uniforms for sprite sheet generation
    var rotate vec3 = vec3(RotationX, RotationY, RotationZ)
    
    var sinX float = sin(rotate.x)
    var cosX float = cos(rotate.x)
    var sinY float = sin(rotate.y)
    var cosY float = cos(rotate.y)
    var sinZ float = sin(rotate.z)
    var cosZ float = cos(rotate.z)
    
    // Build rotation matrix: X * Y * Z (applying rotations in order)
    var mr mat3 = mat3(vec3(cosX,0.0,sinX),vec3(0.0,1.0,0.0),vec3(-sinX,0.0,cosX));           // X rotation
    mr = mat3(vec3(1.0,0.0,0.0),vec3(0.0,cosY,sinY),vec3(0.0,-sinY,cosY))*mr;                 // Y rotation
    mr = mat3(vec3(cosZ,-sinZ,0.0),vec3(sinZ,cosZ,0.0),vec3(0.0,0.0,1.0))*mr;                 // Z rotation
    var ray vec3 = normalize(vec3(p,2.0))
    
    var light vec3 = vec3(-30.0,0.0,-30.0)
    // Early test with primary ray to check if we hit the object
    var rt vec3 = distObj(pos*mr,ray*mr,pradius,mradius)
    
    // Early exit for background pixels - skip expensive calculations
    if length(rt) > 150.0 {
            return vec4(0.0, 0.0, 0.0, 0.0)

        if Time > 0.0 {
            // s4 := 
    // if fragColor.a < 1.0 {
            s4 := pow(noiseSpace(ray,pos,100.0,mr,0.5,vec3(0.0))*1.8,5.7)
            return vec4((mix(mix(vec3(1.0,0.0,0.0),vec3(0.0,0.0,1.0),s4*3.0),vec3(0.5),pow(s4*2.0,0.1))*s4*0.2) * cos(Time * .1) * 50,1.0)
            // return vec4(0.0, 0.0, 0.0, 1.0)
        } else {
            return vec4(0.0, 0.0, 0.0, 0.0)
        }
    }
    var ray1 vec3 = normalize(vec3(p+vec2(0.0,0.01),2.0))
    var ray2 vec3 = normalize(vec3(p+vec2(0.01,0.0),2.0))
    
    // Only compute normal rays and lighting if we hit the object
    var n1 vec3 = distObj(pos*mr,ray1*mr,pradius,mradius)
    var n2 vec3 = distObj(pos*mr,ray2*mr,pradius,mradius)
    var n vec3 = normalize(cross(n1-rt,n2-rt))
    var lightn vec3 = normalize(light*mr-rt)
    var sd vec3 = distObj((pos-light)*mr,-lightn,pradius,mradius)
    var shadow float = 1.0-clamp(pow(length(sd+light*mr-rt),2.0)*200.0,0.0,1.0)
    
    // Moon rock object hit: calculate surface color based on depth and lighting
    fragColor := vec4(0.0, 0.0, 0.0, 1.0)
    rt = rt-pos*mr
    fd := (length(rt)-mradius)/(pradius-mradius)
    c := dot(n,lightn)*shadow
    if fd < line {
        // Inner/crater area: use InnerColorDark to InnerColorLight based on noise
        fragColor.xyz = mix(InnerColorDark, InnerColorLight, noise3(rt*128.0)*0.9+noise3(rt*8.0)*0.1)*c
    } else {
        // Outer surface: use OuterColorDark to OuterColorLight based on noise (highlight removed)
        fragColor.xyz = mix(OuterColorLight, OuterColorDark, noise3(rt*128.0)*0.9+noise3(rt*8.0)*0.1)*c
        // Original with bright highlight: mix(mix(OuterColorLight, OuterColorDark, noise3(rt*128.0)*0.9+noise3(rt*8.0)*0.1),vec3(1.0),pow(fd+0.5,10.0))*c
    }
    
    return min(vec4(1.0), fragColor)
}

