//go:build ignore

//kage:unit pixels

package shaders            



var (
    Time float
    Resolution vec2
    Mouse vec2

)

const (

    pradius float = 1.3
    mradius float = 0.1
    iterations int = 20
    shadowit float = 10.0
    line float = 0.39

    // NCa vec4 = 
    // NCb vec4 = vec4(1.0, 158.0, 114.0, 271.0)
)

func hash4(n vec4) vec4 {
    return fract(sin(n)*753.5453123)
}

func noise3(x vec3) float {
    var p vec3 = floor(x)
    var f vec3 = fract(x)
    f = f*f*(3.0-2.0*f);
    var n float = p.x + dot(p.yz,vec2(157.0,113.0))
    var s1 vec4 = mix(hash4(vec4(n)+vec4(0.0, 157.0, 113.0, 270.0)),hash4(vec4(n)+vec4(1.0, 158.0, 114.0, 271.0)),vec4(f.x))
    return mix(mix(s1.x,s1.y,f.y),mix(s1.z,s1.w,f.y),f.z)
}

func heightMap(rad vec3, d float) float {
    var (
        iline float = 1.0 / (1.0 - line)
        a float = noise3(rad * 1.6) * 0.885
        na = a
    )

    if a > line {
        a = pow((a-line) * iline, 1.8) * (1.0 - line) + line
    }

    if abs(d-a) < 0.2 {
        na = na + noise3(rad * 8.0) * 0.1
        a = na
        if a > line {
            a = pow((a-line) * iline, 1.8) * (1.0 - line) + line
        }
    }
    if abs(d-a) < 0.02 {
        na = na + noise3(rad*32.0) * .01
        a = na
        if a > line {
            a = pow((a-line) * iline, 1.8) * (1.0 - line) + line
        }
    }
    if abs(d-a) < 0.01 {
        a = a + noise3(rad * 128.0) * 0.005
    }

    return a
}

func distObj(pos, ray vec3, radius, minr float) vec3 {
    var (
        b float = dot(ray, pos)
        c float = dot(pos, pos) - b*b

        sta float = radius - minr
        invm float = 1.0 / sta
        rq float = radius * radius
        dist vec3 = ray * 10000.0
    )
    if c < rq {
        r1 := (ray * (abs(b) - sqrt(rq-c)) - pos)
        var maxs float = abs(dot(r1, ray)) // * 0.5
        if c < minr * minr {
            var r2 vec3 = (ray * (abs(b) - sqrt(minr * minr) - c) - pos)
            maxs = maxs - abs(dot(r2, ray))
        }
        maxs = maxs * 0.5

        var len, h float
        for m := 0; m < iterations ; m++ {
            len = length(r1)
            var d vec3 = r1/len
            h = sta * heightMap(d, (len - minr) * invm) + minr
            if abs(h - len) < 0.0001 {
                break
            }
            maxs = abs(maxs)
            if len < h {
                maxs = -1.0 * maxs
            }
            r1 = r1 + (ray * maxs * abs(len - h))
            maxs *= 0.99
        }
        if (len < h +0.1) {
            dist = r1 + pos
        }
    }
    return dist
}

func noiseSpace(ray, pos vec3, r float, mr mat3, zoom float, subnoise vec3) float {
    var (
        b float = dot(ray, pos)
        c float = dot(pos, pos) - b*b
        // r1 vec3 = vec3(0.0)

        s float = 0.0
        d float = 0.0625 * 1.5
        d2 float = zoom / d
        // rq float = r * r
        l1 float = sqrt(abs(r - c))
        
        r1 vec3 = (ray * (b - l1) - pos) * mr
    )
    r1 = r1 * d2

    s = s + abs(noise3(vec3(r1 + subnoise)) * d)
    s = s + abs(noise3(vec3(r1*0.5 + subnoise)) * d * 2.0) 
    s = s + abs(noise3(vec3(r1*0.25 + subnoise)) * d * 4.0) 
    return s
}

func Fragment(dstPos vec4, srcPos vec2, _ vec4) vec4 {
    var p vec2 = (srcPos*2.0 - imageDstSize().xy) / imageDstSize().y
    var mx, my float
    if Mouse.x > 0.0 {
        mx = Mouse.x / Resolution.x * 10.0
    } else {
        mx = 0.5
    }
    if Mouse.y > 0.0 {
        my = Mouse.y / Resolution.y * 4.0 - 2.0
    } else {
        my = 0.0
    }

    var rotate vec2 = vec2(mx + Time * 0.02, my)
    var sins vec2 = sin(rotate)
    var coss vec2 = cos(rotate)
    var mr mat3 = mat3(vec3(coss.x,0.0,sins.x),vec3(0.0,1.0,0.0),vec3(-sins.x,0.0,coss.x));
    mr = mat3(vec3(1.0,0.0,0.0),vec3(0.0,coss.y,sins.y),vec3(0.0,-sins.y,coss.y))*mr;    
    var ray vec3 = normalize(vec3(p,2.0))
    var ray1 vec3 = normalize(vec3(p+vec2(0.0,0.01),2.0))
    var ray2 vec3 = normalize(vec3(p+vec2(0.01,0.0),2.0))
    var pos vec3 = vec3(0.0,0.0,3.0)
    var light vec3 = vec3(-30.0,0.0,-30.0)
    var n1 vec3 = distObj(pos*mr,ray1*mr,pradius,mradius)
    var n2 vec3 = distObj(pos*mr,ray2*mr,pradius,mradius)
    var rt vec3 = distObj(pos*mr,ray*mr,pradius,mradius)
    var lightn vec3 = normalize(light*mr-rt)
    var sd vec3 = distObj((pos-light)*mr,-lightn,pradius,mradius)
    var shadow float = 1.0-clamp(pow(length(sd+light*mr-rt),2.0)*200.0,0.0,1.0)
    var n vec3 = normalize(cross(n1-rt,n2-rt))
    
    // Build fragColor
    fragColor := vec4(0.0, 0.0, 0.0, 1.0)
    
    if length(n1)>100.0 || length(n2)>100.0 || length(rt)>100.0 {
        fragColor.a = 0.0
    }
    
    s4 := noiseSpace(ray,pos,100.0,mr,0.5,vec3(0.0))
    if fragColor.a < 1.0 {
        s4 = pow(s4*1.8,5.7)
        fragColor = vec4((mix(mix(vec3(1.0,0.0,0.0),vec3(0.0,0.0,1.0),s4*3.0),vec3(0.5),pow(s4*2.0,0.1))*s4*0.2),1.0)
    } else {
        rt = rt-pos*mr
        fd := (length(rt)-mradius)/(pradius-mradius)
        c := dot(n,lightn)*shadow
        if fd < line {
            fragColor.xyz = mix(vec3(0.21,0.19,0.0),vec3(1.0,0.99,1.0),noise3(rt*128.0)*0.9+noise3(rt*8.0)*0.1)*c
        } else {
            fragColor.xyz = mix(mix(vec3(1.0,1.0,0.9),vec3(0.8,0.79,0.7),noise3(rt*128.0)*0.9+noise3(rt*8.0)*0.1),vec3(1.0),pow(fd+0.5,10.0))*c
        }
    }
    
    return min(vec4(1.0), fragColor)
}

